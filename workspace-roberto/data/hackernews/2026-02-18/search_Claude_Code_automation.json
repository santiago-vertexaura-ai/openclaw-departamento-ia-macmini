{"exhaustive":{"nbHits":false,"typo":false},"exhaustiveNbHits":false,"exhaustiveTypo":false,"hits":[{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"uejfiweun"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"At my large tech company, we're all being pushed to use AI. I, and most people I work with, have had success using the chatbots and Cursor-style tools and more recently <em>Claude</em> <em>Code</em> to accelerate the process of writing <em>code</em>.<p>Yet, with a few people in my network, it's like they're living 10 years ahead. Guys are <em>automatin</em>g everything in their jobs, spinning up 10 specialized agents at a time and running multi-agent pipelines, just doing all sorts of crazy things with this tech that I just can't even fathom. It seems like it's making them way more productive.<p>I have found a way to fit <em>code</em>-writing and question-answering chatbots into my workflow. I have NOT done the same in terms of these crazy Agent setups. There's clearly a way to leverage these tools to turbocharge your productivity, like at least 2x or maybe even 10x. But what is it?<p>Are there any Agentic power users out there who can enlighten me? What are the best ways to take advantage of these new tools?"},"title":{"matchLevel":"none","matchedWords":[],"value":"Ask HN: Any AI / Agent power users out there? Do you have any tips?"}},"_tags":["story","author_uejfiweun","story_47058199","ask_hn"],"author":"uejfiweun","children":[47059255,47060319,47059094],"created_at":"2026-02-18T07:15:50Z","created_at_i":1771398950,"num_comments":3,"objectID":"47058199","points":3,"story_id":47058199,"story_text":"At my large tech company, we&#x27;re all being pushed to use AI. I, and most people I work with, have had success using the chatbots and Cursor-style tools and more recently Claude Code to accelerate the process of writing code.<p>Yet, with a few people in my network, it&#x27;s like they&#x27;re living 10 years ahead. Guys are automating everything in their jobs, spinning up 10 specialized agents at a time and running multi-agent pipelines, just doing all sorts of crazy things with this tech that I just can&#x27;t even fathom. It seems like it&#x27;s making them way more productive.<p>I have found a way to fit code-writing and question-answering chatbots into my workflow. I have NOT done the same in terms of these crazy Agent setups. There&#x27;s clearly a way to leverage these tools to turbocharge your productivity, like at least 2x or maybe even 10x. But what is it?<p>Are there any Agentic power users out there who can enlighten me? What are the best ways to take advantage of these new tools?","title":"Ask HN: Any AI / Agent power users out there? Do you have any tips?","updated_at":"2026-02-18T12:39:06Z"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"Directshell"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"I built a Rust binary (~700KB, two dependencies) that snaps onto any Windows application, continuously reads its UI <em>Automation</em> accessibility tree into a SQLite database, and lets external processes control the app via SQL INSERT.<p>The <em>core</em> insight: every GUI application already describes itself as structured text through the accessibility layer (built for screen readers since 1997). Every major AI lab is taking screenshots of this and running vision models on it. DirectShell just reads the text directly.<p>What it does:\n- Reads every button, field, menu item into a queryable SQLite DB (refreshed every 500ms)\n- Generates multiple output formats: full DB, interactive elements list, LLM-optimized snapshots (50-200 tokens vs 1,200-5,000 for a screenshot)\n- Controls apps via 5 action types: click by element name, set text via UIA ValuePattern, type character-by-character, send key combos, scroll\n- Includes an MCP server so <em>Claude</em>/GPT can use it directly<p>Day 1 demo: filled 360 Google Sheets cells in 90 seconds, read and replied to a <em>Claude</em>.ai conversation cross-app, wrote to Notepad instantly. No screenshots, no vision model, no coordinate guessing.<p>Limitations (honest): built in 8.5 hours, single-app scope, Chromium apps need a 4-phase activation hack to expose their tree, accessibility quality varies by app. AGPL-3.0.<p>Demo: <a href=\"https://youtu.be/nvZobyt0KBg\" rel=\"nofollow\">https://youtu.be/nvZobyt0KBg</a>\nFull technical paper: in the repo under Dokumentation/ and on <a href=\"https://dev.to/tlrag/i-built-a-new-software-primitive-in-85-hours-it-replaces-the-eyes-of-every-ai-agent-on-earth-55ia\" rel=\"nofollow\">https://dev.to/tlrag/i-built-a-new-software-primitive-in-85-...</a>"},"title":{"matchLevel":"none","matchedWords":[],"value":"Show HN: I built a new software primitive. It replaces AI screenshot agents"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://github.com/IamLumae/DirectShell"}},"_tags":["story","author_Directshell","story_47051496","show_hn"],"author":"Directshell","created_at":"2026-02-17T18:57:45Z","created_at_i":1771354665,"num_comments":0,"objectID":"47051496","points":4,"story_id":47051496,"story_text":"I built a Rust binary (~700KB, two dependencies) that snaps onto any Windows application, continuously reads its UI Automation accessibility tree into a SQLite database, and lets external processes control the app via SQL INSERT.<p>The core insight: every GUI application already describes itself as structured text through the accessibility layer (built for screen readers since 1997). Every major AI lab is taking screenshots of this and running vision models on it. DirectShell just reads the text directly.<p>What it does:\n- Reads every button, field, menu item into a queryable SQLite DB (refreshed every 500ms)\n- Generates multiple output formats: full DB, interactive elements list, LLM-optimized snapshots (50-200 tokens vs 1,200-5,000 for a screenshot)\n- Controls apps via 5 action types: click by element name, set text via UIA ValuePattern, type character-by-character, send key combos, scroll\n- Includes an MCP server so Claude&#x2F;GPT can use it directly<p>Day 1 demo: filled 360 Google Sheets cells in 90 seconds, read and replied to a Claude.ai conversation cross-app, wrote to Notepad instantly. No screenshots, no vision model, no coordinate guessing.<p>Limitations (honest): built in 8.5 hours, single-app scope, Chromium apps need a 4-phase activation hack to expose their tree, accessibility quality varies by app. AGPL-3.0.<p>Demo: <a href=\"https:&#x2F;&#x2F;youtu.be&#x2F;nvZobyt0KBg\" rel=\"nofollow\">https:&#x2F;&#x2F;youtu.be&#x2F;nvZobyt0KBg</a>\nFull technical paper: in the repo under Dokumentation&#x2F; and on <a href=\"https:&#x2F;&#x2F;dev.to&#x2F;tlrag&#x2F;i-built-a-new-software-primitive-in-85-hours-it-replaces-the-eyes-of-every-ai-agent-on-earth-55ia\" rel=\"nofollow\">https:&#x2F;&#x2F;dev.to&#x2F;tlrag&#x2F;i-built-a-new-software-primitive-in-85-...</a>","title":"Show HN: I built a new software primitive. It replaces AI screenshot agents","updated_at":"2026-02-17T21:16:35Z","url":"https://github.com/IamLumae/DirectShell"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"WeberG619"},"title":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"Show HN: Agent Forge \u2013 Persistent memory and desktop <em>automation</em> for <em>Claude</em> <em>Code</em>"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://github.com/WeberG619/agent-forge"}},"_tags":["story","author_WeberG619","story_47044282","show_hn"],"author":"WeberG619","created_at":"2026-02-17T06:16:11Z","created_at_i":1771308971,"num_comments":0,"objectID":"47044282","points":3,"story_id":47044282,"title":"Show HN: Agent Forge \u2013 Persistent memory and desktop automation for Claude Code","updated_at":"2026-02-17T08:50:47Z","url":"https://github.com/WeberG619/agent-forge"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"dcellison"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"I built Kai because I wanted <em>Claude</em> <em>Code</em>'s full capabilities - shell access, file editing, git, web search - available from my phone, without being tied to a terminal.<p>Kai is a Telegram bot that wraps a persistent <em>Claude</em> <em>Code</em> process. You send messages in Telegram, and <em>Claude</em> responds with full tool access: it can read and edit files, run commands, manage git branches, search the web, and work across multiple projects. Responses stream back in real time. Everything runs on your own machine.<p>*How I actually use it:* I point Kai at a project workspace and use it as a dev assistant. It has the full context of whatever repo it's looking at - it can read and write <em>code</em>, check git status, run tests, make commits. Switching between projects is a Telegram command. I can be away from my desk and tell it &quot;fix the failing CI on the web repo&quot; or &quot;add input validation to the signup form&quot; and it just does it.<p>*Background:* I originally ran an instance of an open-source bot framework, but shut it down after a few days due to security concerns. I rebuilt from scratch on top of <em>Claude</em> <em>Code</em>'s CLI, which handles sandboxing and tool execution properly.<p>*No AI API keys required:* Kai doesn't call the Anthropic API directly - it wraps a logged-in <em>Claude</em> <em>Code</em> session, so there are no API keys to manage and no per-token costs beyond your existing <em>Claude</em> <em>Code</em> subscription. The original design eliminated all API keys after security problems with another bot framework that managed them insecurely. Now that Kai runs on a trustworthy local foundation, optional service integrations are safe.<p>*Privacy angle:* Kai runs locally - on a Mac mini in my case. Conversations, credentials, and project files never leave the machine. There's no server component, no cloud relay. Your Telegram messages go to your machine, and <em>Claude</em> <em>Code</em> handles the rest through Anthropic's API directly.<p>*External services without MCP:* Kai has a declarative HTTP service layer for connecting to any REST API. You define services in a YAML config - URL, method, auth type - and Kai makes the HTTP calls directly. No plugins, no third-party server processes, no executable <em>code</em>. API keys stay in your `.env` and are never touched by intermediary <em>code</em>. Ships with a Perplexity config for web search, but the same pattern works for weather APIs, notification services (Pushover, ntfy), home <em>automation</em>, translation, or anything else with a REST endpoint. Entirely optional - Kai works fine without it.<p>*Some things it can do:*<p>- Connect to external REST APIs via declarative config (search, weather, notifications, etc.)\n- Transcribe voice messages locally (whisper.cpp) and respond with voice (Piper TTS)\n- Run scheduled jobs and reminders\n- Receive GitHub webhooks (push, PR, issue notifications)\n- Stream responses in real time (message updates every 2s)\n- Switch between workspaces and models via Telegram commands<p>It's a single Python package, about 1700 lines across 11 modules. Runs as a launchd/systemd service. Setup is: clone, pip install, set two env vars (Telegram token + your user ID), and `make run`.<p>Repo: <a href=\"https://github.com/dcellison/kai\" rel=\"nofollow\">https://github.com/dcellison/kai</a><p>Happy to answer any questions about the setup or architecture."},"title":{"fullyHighlighted":false,"matchLevel":"partial","matchedWords":["claude","code"],"value":"Show HN: Kai \u2013 A Telegram bot that turns <em>Claude</em> <em>Code</em> into a personal dev asst"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://github.com/dcellison/kai"}},"_tags":["story","author_dcellison","story_47034875","show_hn"],"author":"dcellison","children":[47037167],"created_at":"2026-02-16T13:47:46Z","created_at_i":1771249666,"num_comments":2,"objectID":"47034875","points":1,"story_id":47034875,"story_text":"I built Kai because I wanted Claude Code&#x27;s full capabilities - shell access, file editing, git, web search - available from my phone, without being tied to a terminal.<p>Kai is a Telegram bot that wraps a persistent Claude Code process. You send messages in Telegram, and Claude responds with full tool access: it can read and edit files, run commands, manage git branches, search the web, and work across multiple projects. Responses stream back in real time. Everything runs on your own machine.<p>*How I actually use it:* I point Kai at a project workspace and use it as a dev assistant. It has the full context of whatever repo it&#x27;s looking at - it can read and write code, check git status, run tests, make commits. Switching between projects is a Telegram command. I can be away from my desk and tell it &quot;fix the failing CI on the web repo&quot; or &quot;add input validation to the signup form&quot; and it just does it.<p>*Background:* I originally ran an instance of an open-source bot framework, but shut it down after a few days due to security concerns. I rebuilt from scratch on top of Claude Code&#x27;s CLI, which handles sandboxing and tool execution properly.<p>*No AI API keys required:* Kai doesn&#x27;t call the Anthropic API directly - it wraps a logged-in Claude Code session, so there are no API keys to manage and no per-token costs beyond your existing Claude Code subscription. The original design eliminated all API keys after security problems with another bot framework that managed them insecurely. Now that Kai runs on a trustworthy local foundation, optional service integrations are safe.<p>*Privacy angle:* Kai runs locally - on a Mac mini in my case. Conversations, credentials, and project files never leave the machine. There&#x27;s no server component, no cloud relay. Your Telegram messages go to your machine, and Claude Code handles the rest through Anthropic&#x27;s API directly.<p>*External services without MCP:* Kai has a declarative HTTP service layer for connecting to any REST API. You define services in a YAML config - URL, method, auth type - and Kai makes the HTTP calls directly. No plugins, no third-party server processes, no executable code. API keys stay in your `.env` and are never touched by intermediary code. Ships with a Perplexity config for web search, but the same pattern works for weather APIs, notification services (Pushover, ntfy), home automation, translation, or anything else with a REST endpoint. Entirely optional - Kai works fine without it.<p>*Some things it can do:*<p>- Connect to external REST APIs via declarative config (search, weather, notifications, etc.)\n- Transcribe voice messages locally (whisper.cpp) and respond with voice (Piper TTS)\n- Run scheduled jobs and reminders\n- Receive GitHub webhooks (push, PR, issue notifications)\n- Stream responses in real time (message updates every 2s)\n- Switch between workspaces and models via Telegram commands<p>It&#x27;s a single Python package, about 1700 lines across 11 modules. Runs as a launchd&#x2F;systemd service. Setup is: clone, pip install, set two env vars (Telegram token + your user ID), and `make run`.<p>Repo: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;dcellison&#x2F;kai\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;dcellison&#x2F;kai</a><p>Happy to answer any questions about the setup or architecture.","title":"Show HN: Kai \u2013 A Telegram bot that turns Claude Code into a personal dev asst","updated_at":"2026-02-17T19:36:19Z","url":"https://github.com/dcellison/kai"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"rookedsysc"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"I run multiple <em>Claude</em> <em>Code</em> agents in parallel across different branches. Checking each tmux session one by one to see which agent was working, waiting for input, or done was painful.<p>KanVibe is a self-hosted Kanban board for this. Three things it does:<p>- *Browser terminals*: Every task card has a live terminal (xterm.js). Click a task, see its output. No tmux attach needed.\n- *Hook-driven status tracking*: <em>Claude</em> <em>Code</em> Hooks auto-move cards across the board (PROGRESS \u2192 PENDING \u2192 REVIEW). Zero manual updates.\n- *Git worktree <em>automation</em>*: Create a task with a branch name \u2192 worktree + terminal session auto-created. Move to DONE \u2192 everything auto-cleaned.<p>Setup: `git clone` + `bash start.sh`. Requires Node.js 22+, tmux/zellij, and Docker.<p>Built with Next.js 16, React 19, PostgreSQL, xterm.js, and WebSocket. AGPL-3.0 licensed."},"title":{"matchLevel":"none","matchedWords":[],"value":"Show HN: KanVibe \u2013 Kanban board that auto-tracks AI agents via hooks"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://github.com/rookedsysc/kanvibe"}},"_tags":["story","author_rookedsysc","story_47034185","show_hn"],"author":"rookedsysc","children":[47055310],"created_at":"2026-02-16T12:27:38Z","created_at_i":1771244858,"num_comments":1,"objectID":"47034185","points":1,"story_id":47034185,"story_text":"I run multiple Claude Code agents in parallel across different branches. Checking each tmux session one by one to see which agent was working, waiting for input, or done was painful.<p>KanVibe is a self-hosted Kanban board for this. Three things it does:<p>- *Browser terminals*: Every task card has a live terminal (xterm.js). Click a task, see its output. No tmux attach needed.\n- *Hook-driven status tracking*: Claude Code Hooks auto-move cards across the board (PROGRESS \u2192 PENDING \u2192 REVIEW). Zero manual updates.\n- *Git worktree automation*: Create a task with a branch name \u2192 worktree + terminal session auto-created. Move to DONE \u2192 everything auto-cleaned.<p>Setup: `git clone` + `bash start.sh`. Requires Node.js 22+, tmux&#x2F;zellij, and Docker.<p>Built with Next.js 16, React 19, PostgreSQL, xterm.js, and WebSocket. AGPL-3.0 licensed.","title":"Show HN: KanVibe \u2013 Kanban board that auto-tracks AI agents via hooks","updated_at":"2026-02-18T00:10:04Z","url":"https://github.com/rookedsysc/kanvibe"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"tanmay001"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"AI agents often generate inconsistent Playwright tests because they do not understand your application\u2019s specific workflows, UI patterns, or constraints.<p>The Playwright Skill provides more than 70 structured markdown guides that teach patterns for locators, authentication, visual testing, CI configuration, and framework migration so agents can apply consistent solutions instead of guessing.<p>You install it with: npx skills add testdino-hq/playwright-skill.<p>The material is organized into five packs: core testing (46 guides), Playwright CLI usage for token\u2011efficient <em>automation</em> (10), Page Object Model patterns (2), CI/CD setup for major providers (9), and migrations from Cypress or Selenium (2).<p>Each guide follows the same structure\u2014when to use a pattern, when to avoid it, quick reference <em>code</em>, and complete implementations\u2014so learners can move from concept to reliable tests step by step.<p>The skill works with tools such as <em>Claude</em> <em>Code</em>, GitHub Copilot, Cursor, and any agent that implements the skills protocol, and it is MIT\u2011licensed so teams can adapt the content to their own standards and practices.<p>For a deeper walkthrough of the guides and structure, see the full article at <a href=\"https://testdino.com/blog/playwright-skill/\" rel=\"nofollow\">https://testdino.com/blog/playwright-skill/</a>."},"title":{"matchLevel":"none","matchedWords":[],"value":"Show HN: Train AI Agents to Write Better Playwright Tests"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://testdino.com/blog/playwright-skill/"}},"_tags":["story","author_tanmay001","story_47032774","show_hn"],"author":"tanmay001","created_at":"2026-02-16T09:18:10Z","created_at_i":1771233490,"num_comments":0,"objectID":"47032774","points":2,"story_id":47032774,"story_text":"AI agents often generate inconsistent Playwright tests because they do not understand your application\u2019s specific workflows, UI patterns, or constraints.<p>The Playwright Skill provides more than 70 structured markdown guides that teach patterns for locators, authentication, visual testing, CI configuration, and framework migration so agents can apply consistent solutions instead of guessing.<p>You install it with: npx skills add testdino-hq&#x2F;playwright-skill.<p>The material is organized into five packs: core testing (46 guides), Playwright CLI usage for token\u2011efficient automation (10), Page Object Model patterns (2), CI&#x2F;CD setup for major providers (9), and migrations from Cypress or Selenium (2).<p>Each guide follows the same structure\u2014when to use a pattern, when to avoid it, quick reference code, and complete implementations\u2014so learners can move from concept to reliable tests step by step.<p>The skill works with tools such as Claude Code, GitHub Copilot, Cursor, and any agent that implements the skills protocol, and it is MIT\u2011licensed so teams can adapt the content to their own standards and practices.<p>For a deeper walkthrough of the guides and structure, see the full article at <a href=\"https:&#x2F;&#x2F;testdino.com&#x2F;blog&#x2F;playwright-skill&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;testdino.com&#x2F;blog&#x2F;playwright-skill&#x2F;</a>.","title":"Show HN: Train AI Agents to Write Better Playwright Tests","updated_at":"2026-02-16T09:24:28Z","url":"https://testdino.com/blog/playwright-skill/"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"server-lab"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"I built DoScript, a domain-specific language for file <em>automation</em>. The goal: make scripts readable by anyone.\nDesign Goal\nInstead of:\nbashfind . -type f -mtime +30 -exec rm {} \\;\nWrite:\nfor_each file_in here\n    if_older_than {file_name} 30 days\n        delete file {file_path}\n    end_if\nend_for\nTrade power for clarity. Optimize for maintenance over terseness.\nKey Design Decisions\n1. Natural Language Keywords\nmake folder not mkdir, copy file not cp. Self-documenting.\n2. Implicit Metadata\nWhen iterating files, auto-inject: {file_name}, {file_path}, {file_size}, {file_modified}, {file_is_old_days}\nfor_each file_in &quot;Documents&quot;\n    say &quot;{file_name} is {file_size} bytes&quot;\nend_for\n3. Built-in Time Handling\nif_older_than {file_name} 30 days\nmake folder &quot;backup_{today}&quot;\nNo date arithmetic needed.\n4. Expression Evaluation\nFunction-based for simplicity:\nif greater_than {file_size} 1000000\nif and(equals({type}, &quot;pdf&quot;), greater_than({size}, 10000))\nIntentionally awkward for complex logic - signals you should use Python.\nImplementation<p>Python interpreter (~2000 LOC)\nRecursive descent parser\nContext-aware error reporting\nCustom exception types with file/line info<p>Visual Component\nBuilt a browser-based node editor (single HTML file, 1200 LOC). Drag boxes, wire them, generate DoScript <em>code</em>.\nWhy? Different learning styles, workflow visualization, non-programmer accessibility.\nWhat Worked<p>Natural syntax is immediately understandable\nMetadata injection removes boilerplate\nTime handling makes common cases trivial\nVisual IDE differentiates from text-only<p>What Didn't<p>Complex conditionals get awkward fast\nNo user-defined functions (only macros)\nLimited data structures\nPerformance not optimized<p>The Challenge\nBuilt for non-programmers. But they don't hang out on dev forums. Developers say &quot;just use Python&quot; - which misses the point.\nHow do you market dev tools to non-developers?\nTechnical Transparency\nI designed syntax and architecture. Most Python implementation was AI-assisted (<em>Claude</em>, Copilot). Focus on design, use tools for implementation.\nOpen Questions<p>When does a DSL become too limited?\nHow to market to non-developers?\nType system worth the complexity?\nShould DSLs provide escape hatches to host language?<p>GitHub: <a href=\"https://github.com/TheServer-lab/DoScript\" rel=\"nofollow\">https://github.com/TheServer-lab/DoScript</a>\nv0.6.5, includes interpreter, visual IDE, VS <em>Code</em> extension, examples.\nBuilt because bash was too cryptic for my friend to organize files. Turns out lots of people have this problem.\nWould love feedback from people who've built DSLs or struggled with similar trade-offs."},"title":{"fullyHighlighted":false,"matchLevel":"partial","matchedWords":["automation"],"value":"Show HN: DoScript \u2013 DSL for file <em>automation</em> with natural language syntax"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://github.com/TheServer-lab/DoScript"}},"_tags":["story","author_server-lab","story_47032476","show_hn"],"author":"server-lab","created_at":"2026-02-16T08:37:57Z","created_at_i":1771231077,"num_comments":0,"objectID":"47032476","points":1,"story_id":47032476,"story_text":"I built DoScript, a domain-specific language for file automation. The goal: make scripts readable by anyone.\nDesign Goal\nInstead of:\nbashfind . -type f -mtime +30 -exec rm {} \\;\nWrite:\nfor_each file_in here\n    if_older_than {file_name} 30 days\n        delete file {file_path}\n    end_if\nend_for\nTrade power for clarity. Optimize for maintenance over terseness.\nKey Design Decisions\n1. Natural Language Keywords\nmake folder not mkdir, copy file not cp. Self-documenting.\n2. Implicit Metadata\nWhen iterating files, auto-inject: {file_name}, {file_path}, {file_size}, {file_modified}, {file_is_old_days}\nfor_each file_in &quot;Documents&quot;\n    say &quot;{file_name} is {file_size} bytes&quot;\nend_for\n3. Built-in Time Handling\nif_older_than {file_name} 30 days\nmake folder &quot;backup_{today}&quot;\nNo date arithmetic needed.\n4. Expression Evaluation\nFunction-based for simplicity:\nif greater_than {file_size} 1000000\nif and(equals({type}, &quot;pdf&quot;), greater_than({size}, 10000))\nIntentionally awkward for complex logic - signals you should use Python.\nImplementation<p>Python interpreter (~2000 LOC)\nRecursive descent parser\nContext-aware error reporting\nCustom exception types with file&#x2F;line info<p>Visual Component\nBuilt a browser-based node editor (single HTML file, 1200 LOC). Drag boxes, wire them, generate DoScript code.\nWhy? Different learning styles, workflow visualization, non-programmer accessibility.\nWhat Worked<p>Natural syntax is immediately understandable\nMetadata injection removes boilerplate\nTime handling makes common cases trivial\nVisual IDE differentiates from text-only<p>What Didn&#x27;t<p>Complex conditionals get awkward fast\nNo user-defined functions (only macros)\nLimited data structures\nPerformance not optimized<p>The Challenge\nBuilt for non-programmers. But they don&#x27;t hang out on dev forums. Developers say &quot;just use Python&quot; - which misses the point.\nHow do you market dev tools to non-developers?\nTechnical Transparency\nI designed syntax and architecture. Most Python implementation was AI-assisted (Claude, Copilot). Focus on design, use tools for implementation.\nOpen Questions<p>When does a DSL become too limited?\nHow to market to non-developers?\nType system worth the complexity?\nShould DSLs provide escape hatches to host language?<p>GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;TheServer-lab&#x2F;DoScript\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;TheServer-lab&#x2F;DoScript</a>\nv0.6.5, includes interpreter, visual IDE, VS Code extension, examples.\nBuilt because bash was too cryptic for my friend to organize files. Turns out lots of people have this problem.\nWould love feedback from people who&#x27;ve built DSLs or struggled with similar trade-offs.","title":"Show HN: DoScript \u2013 DSL for file automation with natural language syntax","updated_at":"2026-02-16T08:42:59Z","url":"https://github.com/TheServer-lab/DoScript"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"tom2948329494"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"I know everybody has their own note-taking system and there are better ways to do this, but:<p>Whenever I need to make quick notes during a meeting, or paste some url / <em>code</em> / whatever to hold it, or paste formatted text to un-format it, I used to open TextEdit.<p>It's the equivalent of taking a scrap piece of paper and jotting something down.<p>These kinds of notes I don't want in any cloud, serious note-taking app or any <em>code</em> editor.<p>But the burden of having 1 extra click on open (new document), and deciding what to do with old notes when closing (delete? save?) was too much.<p>So I built my own notepad which behaves like a super simple textedit, but all notes are <em>automati</em>cally saved to a predefined folder.<p>- Opens with a new note when launched, or re-opened.<p>- Notes can be auto-named by timestamp, numbered &quot;Note N&quot;, custom prefix or by first line of text.<p>- Hideable sidebar shows all notes.<p>- Shortcuts can create, delete, switch between notes.<p>Bonus points for pointing <em>claude</em> <em>code</em> to that folder to organize or work with all notes.<p>Again: This is a custom app I made for myself, so probably it's not useful to anyone, but anyhow:<p><a href=\"https://tomreinert.de/en/verygoodnotepad/\" rel=\"nofollow\">https://tomreinert.de/en/verygoodnotepad/</a><p><a href=\"https://apps.apple.com/us/app/very-good-notepad/id6758906859\">https://apps.apple.com/us/app/very-good-notepad/id6758906859</a><p>PS: This was built with the new <em>Claude</em> <em>Code</em> integration in xcode 26.3, worked quite well."},"title":{"matchLevel":"none","matchedWords":[],"value":"Show HN: Scratchpad app that auto-saves notes as .txt files"}},"_tags":["story","author_tom2948329494","story_47022138","show_hn"],"author":"tom2948329494","created_at":"2026-02-15T08:53:46Z","created_at_i":1771145626,"num_comments":0,"objectID":"47022138","points":1,"story_id":47022138,"story_text":"I know everybody has their own note-taking system and there are better ways to do this, but:<p>Whenever I need to make quick notes during a meeting, or paste some url &#x2F; code &#x2F; whatever to hold it, or paste formatted text to un-format it, I used to open TextEdit.<p>It&#x27;s the equivalent of taking a scrap piece of paper and jotting something down.<p>These kinds of notes I don&#x27;t want in any cloud, serious note-taking app or any code editor.<p>But the burden of having 1 extra click on open (new document), and deciding what to do with old notes when closing (delete? save?) was too much.<p>So I built my own notepad which behaves like a super simple textedit, but all notes are automatically saved to a predefined folder.<p>- Opens with a new note when launched, or re-opened.<p>- Notes can be auto-named by timestamp, numbered &quot;Note N&quot;, custom prefix or by first line of text.<p>- Hideable sidebar shows all notes.<p>- Shortcuts can create, delete, switch between notes.<p>Bonus points for pointing claude code to that folder to organize or work with all notes.<p>Again: This is a custom app I made for myself, so probably it&#x27;s not useful to anyone, but anyhow:<p><a href=\"https:&#x2F;&#x2F;tomreinert.de&#x2F;en&#x2F;verygoodnotepad&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;tomreinert.de&#x2F;en&#x2F;verygoodnotepad&#x2F;</a><p><a href=\"https:&#x2F;&#x2F;apps.apple.com&#x2F;us&#x2F;app&#x2F;very-good-notepad&#x2F;id6758906859\">https:&#x2F;&#x2F;apps.apple.com&#x2F;us&#x2F;app&#x2F;very-good-notepad&#x2F;id6758906859</a><p>PS: This was built with the new Claude Code integration in xcode 26.3, worked quite well.","title":"Show HN: Scratchpad app that auto-saves notes as .txt files","updated_at":"2026-02-15T08:58:25Z"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"mazilin"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"Subject: My attempt at an &quot;OS-inspired&quot; AI architecture\nHi HN,\nI'm a Product Manager, not a systems engineer. I built AI Station Navigator as a proof-of-concept to solve a specific problem I faced: Context Pollution.\nWhen using AI agents for complex tasks, the context window gets cluttered quickly, causing the model to hallucinate or get confused.\nTo solve this, I designed this project using a Computer Architecture Analogy. I treated the agent system like a traditional OS to better manage resources and isolation.\nHere is the mapping I used to design the system:\n-- CPU approx. LLM (<em>Claude</em>)\nThe raw computing power driving the capabilities.\n-- Kernel approx. Orchestration Layer (<em>Claude</em> <em>Code</em> + <em>CLAUDE</em>.md)\nHandles intent recognition, task scheduling, and context management.\n-- Processes approx. Sub-Agents\nThe core feature: Execution runs in isolated sub-agents. When a task is done, the sub-agent &quot;dies,&quot; freeing up context. This prevents the main thread from getting polluted.\n-- Applications approx. Skills (GitHub Repos)\n&quot;App Store-style&quot; installation of tools via GitHub links.\n-- Drivers approx. MCP + Hooks\nStandardized interfaces for external tools and system <em>automation</em>.\n-- Runtime approx. Portable Environment\nSelf-contained Python/Node environment (no installation hell).\nThe <em>Code</em>: <a href=\"https://github.com/canishowtime/ai-station-navigator/\" rel=\"nofollow\">https://github.com/canishowtime/ai-station-navigator/</a>\nI'd love to hear your thoughts on this architectural approach."},"title":{"matchLevel":"none","matchedWords":[],"value":"Show HN: AI Station Navigator \u2013 LLM=CPU, Agents=Processes, Skills=Apps"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://github.com/canishowtime/ai-station-navigator"}},"_tags":["story","author_mazilin","story_47013274","show_hn"],"author":"mazilin","created_at":"2026-02-14T10:05:55Z","created_at_i":1771063555,"num_comments":0,"objectID":"47013274","points":2,"story_id":47013274,"story_text":"Subject: My attempt at an &quot;OS-inspired&quot; AI architecture\nHi HN,\nI&#x27;m a Product Manager, not a systems engineer. I built AI Station Navigator as a proof-of-concept to solve a specific problem I faced: Context Pollution.\nWhen using AI agents for complex tasks, the context window gets cluttered quickly, causing the model to hallucinate or get confused.\nTo solve this, I designed this project using a Computer Architecture Analogy. I treated the agent system like a traditional OS to better manage resources and isolation.\nHere is the mapping I used to design the system:\n-- CPU approx. LLM (Claude)\nThe raw computing power driving the capabilities.\n-- Kernel approx. Orchestration Layer (Claude Code + CLAUDE.md)\nHandles intent recognition, task scheduling, and context management.\n-- Processes approx. Sub-Agents\nThe core feature: Execution runs in isolated sub-agents. When a task is done, the sub-agent &quot;dies,&quot; freeing up context. This prevents the main thread from getting polluted.\n-- Applications approx. Skills (GitHub Repos)\n&quot;App Store-style&quot; installation of tools via GitHub links.\n-- Drivers approx. MCP + Hooks\nStandardized interfaces for external tools and system automation.\n-- Runtime approx. Portable Environment\nSelf-contained Python&#x2F;Node environment (no installation hell).\nThe Code: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;canishowtime&#x2F;ai-station-navigator&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;canishowtime&#x2F;ai-station-navigator&#x2F;</a>\nI&#x27;d love to hear your thoughts on this architectural approach.","title":"Show HN: AI Station Navigator \u2013 LLM=CPU, Agents=Processes, Skills=Apps","updated_at":"2026-02-14T10:09:52Z","url":"https://github.com/canishowtime/ai-station-navigator"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"notkurt"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"If you\u2019ve used <em>Claude</em> <em>Code</em> on anything non-trivial, you\u2019ve hit the wall. The project gets big enough that context falls apart between sessions. You start a new chat, re-explain the architecture, and watch it make the same mistake it made last week. Every session starts with this painful bootstrap where you\u2019re trying to get the model back to where it was yesterday.<p>This obviously assumes <em>Claude</em> <em>Code</em> is doing most of the heavy lifting on your codebase. If you\u2019re only using it for the occasional function, you probably don\u2019t need this.<p>I spent a few days hacking on workarounds for this and eventually pulled them together into Ghost. It hooks into <em>Claude</em> <em>Code</em> sessions, summarises them, and indexes everything into QMD <a href=\"https://github.com/tobi/qmd\" rel=\"nofollow\">https://github.com/tobi/qmd</a> for semantic search.<p>Next session, relevant context gets injected <em>automati</em>cally. What you were working on, what decisions were made, what already failed.<p>It also keeps a mistake ledger. Things that went wrong get tracked and surfaced as warnings so you stop walking into the same walls.<p>Sessions are stored as markdown in .ai-sessions/ (gitignored).<p>Summaries get attached to commits as git notes so context travels with the <em>code</em>. Everything runs locally, nothing leaves your machine.\nBuilt with Bun. Hooks run under 100ms.<p>It\u2019s early and rough but anecdotally it feels like it actually works."},"title":{"fullyHighlighted":false,"matchLevel":"partial","matchedWords":["claude","code"],"value":"Show HN: Ghost \u2013 Session memory for <em>Claude</em> <em>Code</em> (local, qmd, Git-integrated)"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://github.com/notkurt/ghost"}},"_tags":["story","author_notkurt","story_47007379","show_hn"],"author":"notkurt","children":[47011347],"created_at":"2026-02-13T20:25:10Z","created_at_i":1771014310,"num_comments":1,"objectID":"47007379","points":2,"story_id":47007379,"story_text":"If you\u2019ve used Claude Code on anything non-trivial, you\u2019ve hit the wall. The project gets big enough that context falls apart between sessions. You start a new chat, re-explain the architecture, and watch it make the same mistake it made last week. Every session starts with this painful bootstrap where you\u2019re trying to get the model back to where it was yesterday.<p>This obviously assumes Claude Code is doing most of the heavy lifting on your codebase. If you\u2019re only using it for the occasional function, you probably don\u2019t need this.<p>I spent a few days hacking on workarounds for this and eventually pulled them together into Ghost. It hooks into Claude Code sessions, summarises them, and indexes everything into QMD <a href=\"https:&#x2F;&#x2F;github.com&#x2F;tobi&#x2F;qmd\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;tobi&#x2F;qmd</a> for semantic search.<p>Next session, relevant context gets injected automatically. What you were working on, what decisions were made, what already failed.<p>It also keeps a mistake ledger. Things that went wrong get tracked and surfaced as warnings so you stop walking into the same walls.<p>Sessions are stored as markdown in .ai-sessions&#x2F; (gitignored).<p>Summaries get attached to commits as git notes so context travels with the code. Everything runs locally, nothing leaves your machine.\nBuilt with Bun. Hooks run under 100ms.<p>It\u2019s early and rough but anecdotally it feels like it actually works.","title":"Show HN: Ghost \u2013 Session memory for Claude Code (local, qmd, Git-integrated)","updated_at":"2026-02-14T03:50:22Z","url":"https://github.com/notkurt/ghost"}],"hitsPerPage":10,"nbHits":252,"nbPages":26,"page":0,"params":"query=Claude+Code+automation&tags=story&hitsPerPage=10&advancedSyntax=true&analyticsTags=backend","processingTimeMS":87,"processingTimingsMS":{"_request":{"roundTrip":19},"afterFetch":{"format":{"highlighting":2,"total":2},"merge":{"entries":{"decompress":7,"total":7},"mergeLoop":{"total":5},"total":20},"total":20},"fetch":{"query":49,"scanning":15,"total":65},"total":87},"query":"Claude Code automation","serverTimeMS":89}
