{"exhaustive":{"nbHits":false,"typo":false},"exhaustiveNbHits":false,"exhaustiveTypo":false,"hits":[{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"WeberG619"},"title":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"Show HN: Agent Forge \u2013 Persistent memory and desktop <em>automation</em> for <em>Claude</em> <em>Code</em>"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://github.com/WeberG619/agent-forge"}},"_tags":["story","author_WeberG619","story_47044282","show_hn"],"author":"WeberG619","created_at":"2026-02-17T06:16:11Z","created_at_i":1771308971,"num_comments":0,"objectID":"47044282","points":3,"story_id":47044282,"title":"Show HN: Agent Forge \u2013 Persistent memory and desktop automation for Claude Code","updated_at":"2026-02-17T08:50:47Z","url":"https://github.com/WeberG619/agent-forge"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"coolwulf"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"Hey HN,<p>I've been building CoolWulf AI (<a href=\"https://coolwulfai.com\" rel=\"nofollow\">https://coolwulfai.com</a>), a self-hosted personal AI assistant. After seeing OpenClaw blow up, I wanted to share what I've been working on \u2014 a different approach to the same problem.<p>*Why I built this:*<p>I tried OpenClaw and found the <em>Node</em>.js/TypeScript stack heavy for what's essentially a local agent. pnpm, <em>Node</em> 22+, React \u2014 lots of moving parts. I wanted something that's a single binary, zero runtime dependencies, and feels native on macOS. So I built it in Go.<p>*How it's different from OpenClaw:*<p>- *Single binary, no runtime needed.* Download, set your API key, run. No <em>Node</em>.js, no pnpm, no build step. One ~100 MB binary.\n- *Built in Go.* Fast startup, low memory footprint, compiles to a native executable. No garbage collector pauses from a JS runtime sitting in the background.\n- *macOS-native integrations.* Deep AppleScript-based control of Apple Notes, Reminders, Calendar, Terminal.app, and WeChat desktop. These aren't browser hacks \u2014 they use the native accessibility and scripting APIs.\n- *WeChat support.* This was a big one for me. WeChat desktop on macOS is a native Cocoa/Qt app with a readable accessibility tree. CoolWulf can read messages, send messages, search contacts, and navigate chats \u2014 all via AX APIs and CGEvent. I haven't seen another AI agent do this.\n- *Simpler setup.* Web-based first-time wizard. Configure your LLM provider, connect Gmail/Calendar via OAuth, enable messaging connectors \u2014 all from the browser. No terminal wizards, no YAML files.<p>*What it does:*<p>- 20+ LLM providers (OpenAI, <em>Claude</em>, Gemini, DeepSeek, Groq, Ollama, local models via vLLM/LM Studio)\n- Messaging: WhatsApp, Teams, Telegram, Slack, WeChat\n- Email: Gmail and Yahoo Mail with full OAuth\n- Calendar: Google Calendar + Apple Calendar\n- Browser <em>automation</em>: Chrome CDP + Playwright via MCP\n- Task management: org-mode style with scheduled tasks, cron jobs, automatic execution\n- Persistent memory: SQLite + vector embeddings for semantic search across conversations\n- Background heartbeat: runs 24/7, monitors your systems, executes due tasks, sends alerts\n- Web dashboard for chat, tasks, scheduled jobs, and settings<p>*Architecture choices:*<p>Go was the right call. The binary compiles in seconds, cross-compiles trivially, and the concurrency model (goroutines for heartbeat, browser sessions, connector polling) maps perfectly to an always-on agent. SQLite with vector extensions (sqlite-vec) gives us semantic memory without running a separate vector DB.<p>Try it: <a href=\"https://coolwulfai.com\" rel=\"nofollow\">https://coolwulfai.com</a><p>Happy to answer questions about the Go implementation, WeChat <em>automation</em>, or the macOS accessibility approach."},"title":{"matchLevel":"none","matchedWords":[],"value":"Show HN: CoolWulf AI \u2013 A personal AI assistant built in Go, optimized for macOS"},"url":{"matchLevel":"none","matchedWords":[],"value":"http://coolwulfAI.com"}},"_tags":["story","author_coolwulf","story_47044036","show_hn"],"author":"coolwulf","children":[47044074],"created_at":"2026-02-17T05:32:16Z","created_at_i":1771306336,"num_comments":1,"objectID":"47044036","points":1,"story_id":47044036,"story_text":"Hey HN,<p>I&#x27;ve been building CoolWulf AI (<a href=\"https:&#x2F;&#x2F;coolwulfai.com\" rel=\"nofollow\">https:&#x2F;&#x2F;coolwulfai.com</a>), a self-hosted personal AI assistant. After seeing OpenClaw blow up, I wanted to share what I&#x27;ve been working on \u2014 a different approach to the same problem.<p>*Why I built this:*<p>I tried OpenClaw and found the Node.js&#x2F;TypeScript stack heavy for what&#x27;s essentially a local agent. pnpm, Node 22+, React \u2014 lots of moving parts. I wanted something that&#x27;s a single binary, zero runtime dependencies, and feels native on macOS. So I built it in Go.<p>*How it&#x27;s different from OpenClaw:*<p>- *Single binary, no runtime needed.* Download, set your API key, run. No Node.js, no pnpm, no build step. One ~100 MB binary.\n- *Built in Go.* Fast startup, low memory footprint, compiles to a native executable. No garbage collector pauses from a JS runtime sitting in the background.\n- *macOS-native integrations.* Deep AppleScript-based control of Apple Notes, Reminders, Calendar, Terminal.app, and WeChat desktop. These aren&#x27;t browser hacks \u2014 they use the native accessibility and scripting APIs.\n- *WeChat support.* This was a big one for me. WeChat desktop on macOS is a native Cocoa&#x2F;Qt app with a readable accessibility tree. CoolWulf can read messages, send messages, search contacts, and navigate chats \u2014 all via AX APIs and CGEvent. I haven&#x27;t seen another AI agent do this.\n- *Simpler setup.* Web-based first-time wizard. Configure your LLM provider, connect Gmail&#x2F;Calendar via OAuth, enable messaging connectors \u2014 all from the browser. No terminal wizards, no YAML files.<p>*What it does:*<p>- 20+ LLM providers (OpenAI, Claude, Gemini, DeepSeek, Groq, Ollama, local models via vLLM&#x2F;LM Studio)\n- Messaging: WhatsApp, Teams, Telegram, Slack, WeChat\n- Email: Gmail and Yahoo Mail with full OAuth\n- Calendar: Google Calendar + Apple Calendar\n- Browser automation: Chrome CDP + Playwright via MCP\n- Task management: org-mode style with scheduled tasks, cron jobs, automatic execution\n- Persistent memory: SQLite + vector embeddings for semantic search across conversations\n- Background heartbeat: runs 24&#x2F;7, monitors your systems, executes due tasks, sends alerts\n- Web dashboard for chat, tasks, scheduled jobs, and settings<p>*Architecture choices:*<p>Go was the right call. The binary compiles in seconds, cross-compiles trivially, and the concurrency model (goroutines for heartbeat, browser sessions, connector polling) maps perfectly to an always-on agent. SQLite with vector extensions (sqlite-vec) gives us semantic memory without running a separate vector DB.<p>Try it: <a href=\"https:&#x2F;&#x2F;coolwulfai.com\" rel=\"nofollow\">https:&#x2F;&#x2F;coolwulfai.com</a><p>Happy to answer questions about the Go implementation, WeChat automation, or the macOS accessibility approach.","title":"Show HN: CoolWulf AI \u2013 A personal AI assistant built in Go, optimized for macOS","updated_at":"2026-02-17T06:39:16Z","url":"http://coolwulfAI.com"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"rittermax"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"Start a task, grab a coffee, come back to production-grade <em>code</em>.  \nTests enforced. Context preserved. Quality automated.<p><em>Claude</em> <em>Code</em> moves fast but without structure, it skips tests, loses context, and produces inconsistent results \u2014 especially on complex, established codebases. I tried other frameworks \u2014 they burned tokens on bloated prompts without adding real value. Some added process without enforcement. Others were prompt templates that <em>Claude</em> ignored when context got tight. None made <em>Claude</em> reliably produce production-grade <em>code</em>.<p>So I built Pilot. Instead of adding process on top, it bakes quality into every interaction. Linting, formatting, and type checking run as enforced hooks on every edit. TDD is mandatory, not suggested. Context is monitored and preserved across sessions. Every piece of work goes through verification before it's marked done.<p>Pilot optimizes for output quality, not system complexity. The rules are minimal and focused. There's no big learning curve, no project scaffolding to set up, no state files to manage. You install it in any existing project \u2014 no matter how complex \u2014 run `pilot`, then `/sync` to learn your codebase, and the quality guardrails are just there \u2014 hooks, TDD, type checking, formatting \u2014 enforced <em>automatica</em>lly on every edit, in every session.<p>The result: you can actually walk away. Start a `/spec` task, approve the plan, then go grab a coffee. When you come back, the work is done \u2014 tested, verified, formatted, and ready to ship. Hooks preserve state across compaction cycles, persistent memory carries context between sessions, quality hooks catch every mistake along the way, and verifier agents review the <em>code</em> before marking it complete. No babysitting required."},"title":{"fullyHighlighted":false,"matchLevel":"partial","matchedWords":["claude","code"],"value":"Show HN: <em>Claude</em> Pilot \u2013 <em>Claude</em> <em>Code</em> is powerful. Pilot makes it reliable"},"url":{"fullyHighlighted":false,"matchLevel":"partial","matchedWords":["claude"],"value":"https://github.com/maxritter/<em>claude</em>-pilot"}},"_tags":["story","author_rittermax","story_47043847","show_hn"],"author":"rittermax","created_at":"2026-02-17T04:55:29Z","created_at_i":1771304129,"num_comments":0,"objectID":"47043847","points":1,"story_id":47043847,"story_text":"Start a task, grab a coffee, come back to production-grade code.  \nTests enforced. Context preserved. Quality automated.<p>Claude Code moves fast but without structure, it skips tests, loses context, and produces inconsistent results \u2014 especially on complex, established codebases. I tried other frameworks \u2014 they burned tokens on bloated prompts without adding real value. Some added process without enforcement. Others were prompt templates that Claude ignored when context got tight. None made Claude reliably produce production-grade code.<p>So I built Pilot. Instead of adding process on top, it bakes quality into every interaction. Linting, formatting, and type checking run as enforced hooks on every edit. TDD is mandatory, not suggested. Context is monitored and preserved across sessions. Every piece of work goes through verification before it&#x27;s marked done.<p>Pilot optimizes for output quality, not system complexity. The rules are minimal and focused. There&#x27;s no big learning curve, no project scaffolding to set up, no state files to manage. You install it in any existing project \u2014 no matter how complex \u2014 run `pilot`, then `&#x2F;sync` to learn your codebase, and the quality guardrails are just there \u2014 hooks, TDD, type checking, formatting \u2014 enforced automatically on every edit, in every session.<p>The result: you can actually walk away. Start a `&#x2F;spec` task, approve the plan, then go grab a coffee. When you come back, the work is done \u2014 tested, verified, formatted, and ready to ship. Hooks preserve state across compaction cycles, persistent memory carries context between sessions, quality hooks catch every mistake along the way, and verifier agents review the code before marking it complete. No babysitting required.","title":"Show HN: Claude Pilot \u2013 Claude Code is powerful. Pilot makes it reliable","updated_at":"2026-02-17T04:57:01Z","url":"https://github.com/maxritter/claude-pilot"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"xcke"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"I wanted to test how far <em>Claude</em> <em>Code</em> (Opus 4.6) could go building a real CLI tool autonomously \u2014 not just scaffolding, but the full thing: CLI, backends, parser, tests, fuzz tests, docs, and a documentation site.<p>The result is envref, a tool that replaces secret values in .env files with ref:// URIs pointing to where the secret actually lives:<p># .env \u2014 safe to commit\nAPP_NAME=my-app\nDATABASE_URL=ref://secrets/database_url\nAPI_KEY=ref://secrets/api_key<p>Config stays inline. Secrets stay in your OS keychain (or another backend). envref resolve merges them back together at runtime.<p>It plugs into direnv, so resolution happens <em>automatica</em>lly when you cd into a project. The resolve pipeline is optimized for &lt;50ms with 100 variables to keep cd snappy.<p>Seven backend types: OS keychain (macOS/Linux/Windows \u2014 zero setup), a local encrypted vault (age + SQLite, for headless/CI), 1Password, AWS SSM, HashiCorp Vault, OCI Vault,\nand a plugin protocol for anything else.<p>It also does layered .env merging with profiles, variable interpolation, schema validation, a doctor command that scans for common .env issues, and `envref run` to inject\nresolved vars into a subprocess.<p>The experiment: Single Go binary, built across 77 autonomous agent iterations \u2014 ~192M tokens, $170 in API cost, 8 hours 41 minutes of compute time. I defined the goal, set up\nan agent loop with a backlog, and let it run. Happy to answer questions about that process.<p>The tool itself may be useful, but treat it as beta.<p>GitHub: <a href=\"https://github.com/xcke/envref\" rel=\"nofollow\">https://github.com/xcke/envref</a>\nSite: <a href=\"https://xcke.github.io/envref\" rel=\"nofollow\">https://xcke.github.io/envref</a>"},"title":{"matchLevel":"none","matchedWords":[],"value":"Show HN: Envref \u2013 separating secrets from config in .env files"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://xcke.github.io/envref/"}},"_tags":["story","author_xcke","story_47042109","show_hn"],"author":"xcke","created_at":"2026-02-17T00:22:09Z","created_at_i":1771287729,"num_comments":0,"objectID":"47042109","points":1,"story_id":47042109,"story_text":"I wanted to test how far Claude Code (Opus 4.6) could go building a real CLI tool autonomously \u2014 not just scaffolding, but the full thing: CLI, backends, parser, tests, fuzz tests, docs, and a documentation site.<p>The result is envref, a tool that replaces secret values in .env files with ref:&#x2F;&#x2F; URIs pointing to where the secret actually lives:<p># .env \u2014 safe to commit\nAPP_NAME=my-app\nDATABASE_URL=ref:&#x2F;&#x2F;secrets&#x2F;database_url\nAPI_KEY=ref:&#x2F;&#x2F;secrets&#x2F;api_key<p>Config stays inline. Secrets stay in your OS keychain (or another backend). envref resolve merges them back together at runtime.<p>It plugs into direnv, so resolution happens automatically when you cd into a project. The resolve pipeline is optimized for &lt;50ms with 100 variables to keep cd snappy.<p>Seven backend types: OS keychain (macOS&#x2F;Linux&#x2F;Windows \u2014 zero setup), a local encrypted vault (age + SQLite, for headless&#x2F;CI), 1Password, AWS SSM, HashiCorp Vault, OCI Vault,\nand a plugin protocol for anything else.<p>It also does layered .env merging with profiles, variable interpolation, schema validation, a doctor command that scans for common .env issues, and `envref run` to inject\nresolved vars into a subprocess.<p>The experiment: Single Go binary, built across 77 autonomous agent iterations \u2014 ~192M tokens, $170 in API cost, 8 hours 41 minutes of compute time. I defined the goal, set up\nan agent loop with a backlog, and let it run. Happy to answer questions about that process.<p>The tool itself may be useful, but treat it as beta.<p>GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;xcke&#x2F;envref\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;xcke&#x2F;envref</a>\nSite: <a href=\"https:&#x2F;&#x2F;xcke.github.io&#x2F;envref\" rel=\"nofollow\">https:&#x2F;&#x2F;xcke.github.io&#x2F;envref</a>","title":"Show HN: Envref \u2013 separating secrets from config in .env files","updated_at":"2026-02-17T00:24:01Z","url":"https://xcke.github.io/envref/"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"anhm720"},"story_text":{"fullyHighlighted":false,"matchLevel":"partial","matchedWords":["code","automation"],"value":"I built <em>Codex</em> HUD to make <em>Codex</em> CLI sessions easier to monitor without leaving the terminal.\n  It adds a real-time status line with:<p><pre><code>  - active model\n  - project + git branch/dirty state\n  - 5h and 7d usage bars\n  - <em>automatic</em> Spark vs default limit selection\n\n  Quick install:\n\n  git clone https://github.com/anhannin/<em>codex</em>-hud.git\n  cd <em>codex</em>-hud/<em>Codex</em>-HUD\n  ./install.sh\n\n  Feedback I\u2019m looking for:\n\n  - portability across Linux distros/shell setups\n  - readability on narrow terminal widths\n  - edge cases in usage/rate parsing\n\n  Repo issues are welcome if you hit bugs.</code></pre>"},"title":{"fullyHighlighted":false,"matchLevel":"partial","matchedWords":["claude","code"],"value":"Show HN: <em>Codex</em> HUD \u2013 <em>Claude</em>-HUD Style Status Line for <em>Codex</em> CLI"},"url":{"fullyHighlighted":false,"matchLevel":"partial","matchedWords":["code"],"value":"https://github.com/anhannin/<em>codex</em>-hud"}},"_tags":["story","author_anhm720","story_47035002","show_hn"],"author":"anhm720","created_at":"2026-02-16T13:58:26Z","created_at_i":1771250306,"num_comments":0,"objectID":"47035002","points":1,"story_id":47035002,"story_text":"I built Codex HUD to make Codex CLI sessions easier to monitor without leaving the terminal.\n  It adds a real-time status line with:<p><pre><code>  - active model\n  - project + git branch&#x2F;dirty state\n  - 5h and 7d usage bars\n  - automatic Spark vs default limit selection\n\n  Quick install:\n\n  git clone https:&#x2F;&#x2F;github.com&#x2F;anhannin&#x2F;codex-hud.git\n  cd codex-hud&#x2F;Codex-HUD\n  .&#x2F;install.sh\n\n  Feedback I\u2019m looking for:\n\n  - portability across Linux distros&#x2F;shell setups\n  - readability on narrow terminal widths\n  - edge cases in usage&#x2F;rate parsing\n\n  Repo issues are welcome if you hit bugs.</code></pre>","title":"Show HN: Codex HUD \u2013 Claude-HUD Style Status Line for Codex CLI","updated_at":"2026-02-16T14:00:15Z","url":"https://github.com/anhannin/codex-hud"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"dcellison"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"I built Kai because I wanted <em>Claude</em> <em>Code</em>'s full capabilities - shell access, file editing, git, web search - available from my phone, without being tied to a terminal.<p>Kai is a Telegram bot that wraps a persistent <em>Claude</em> <em>Code</em> process. You send messages in Telegram, and <em>Claude</em> responds with full tool access: it can read and edit files, run commands, manage git branches, search the web, and work across multiple projects. Responses stream back in real time. Everything runs on your own machine.<p>*How I actually use it:* I point Kai at a project workspace and use it as a dev assistant. It has the full context of whatever repo it's looking at - it can read and write <em>code</em>, check git status, run tests, make commits. Switching between projects is a Telegram command. I can be away from my desk and tell it &quot;fix the failing CI on the web repo&quot; or &quot;add input validation to the signup form&quot; and it just does it.<p>*Background:* I originally ran an instance of an open-source bot framework, but shut it down after a few days due to security concerns. I rebuilt from scratch on top of <em>Claude</em> <em>Code</em>'s CLI, which handles sandboxing and tool execution properly.<p>*No AI API keys required:* Kai doesn't call the Anthropic API directly - it wraps a logged-in <em>Claude</em> <em>Code</em> session, so there are no API keys to manage and no per-token costs beyond your existing <em>Claude</em> <em>Code</em> subscription. The original design eliminated all API keys after security problems with another bot framework that managed them insecurely. Now that Kai runs on a trustworthy local foundation, optional service integrations are safe.<p>*Privacy angle:* Kai runs locally - on a Mac mini in my case. Conversations, credentials, and project files never leave the machine. There's no server component, no cloud relay. Your Telegram messages go to your machine, and <em>Claude</em> <em>Code</em> handles the rest through Anthropic's API directly.<p>*External services without MCP:* Kai has a declarative HTTP service layer for connecting to any REST API. You define services in a YAML config - URL, method, auth type - and Kai makes the HTTP calls directly. No plugins, no third-party server processes, no executable <em>code</em>. API keys stay in your `.env` and are never touched by intermediary <em>code</em>. Ships with a Perplexity config for web search, but the same pattern works for weather APIs, notification services (Pushover, ntfy), home <em>automation</em>, translation, or anything else with a REST endpoint. Entirely optional - Kai works fine without it.<p>*Some things it can do:*<p>- Connect to external REST APIs via declarative config (search, weather, notifications, etc.)\n- Transcribe voice messages locally (whisper.cpp) and respond with voice (Piper TTS)\n- Run scheduled jobs and reminders\n- Receive GitHub webhooks (push, PR, issue notifications)\n- Stream responses in real time (message updates every 2s)\n- Switch between workspaces and models via Telegram commands<p>It's a single Python package, about 1700 lines across 11 modules. Runs as a launchd/systemd service. Setup is: clone, pip install, set two env vars (Telegram token + your user ID), and `make run`.<p>Repo: <a href=\"https://github.com/dcellison/kai\" rel=\"nofollow\">https://github.com/dcellison/kai</a><p>Happy to answer any questions about the setup or architecture."},"title":{"fullyHighlighted":false,"matchLevel":"partial","matchedWords":["claude","code"],"value":"Show HN: Kai \u2013 A Telegram bot that turns <em>Claude</em> <em>Code</em> into a personal dev asst"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://github.com/dcellison/kai"}},"_tags":["story","author_dcellison","story_47034875","show_hn"],"author":"dcellison","children":[47037167],"created_at":"2026-02-16T13:47:46Z","created_at_i":1771249666,"num_comments":1,"objectID":"47034875","points":1,"story_id":47034875,"story_text":"I built Kai because I wanted Claude Code&#x27;s full capabilities - shell access, file editing, git, web search - available from my phone, without being tied to a terminal.<p>Kai is a Telegram bot that wraps a persistent Claude Code process. You send messages in Telegram, and Claude responds with full tool access: it can read and edit files, run commands, manage git branches, search the web, and work across multiple projects. Responses stream back in real time. Everything runs on your own machine.<p>*How I actually use it:* I point Kai at a project workspace and use it as a dev assistant. It has the full context of whatever repo it&#x27;s looking at - it can read and write code, check git status, run tests, make commits. Switching between projects is a Telegram command. I can be away from my desk and tell it &quot;fix the failing CI on the web repo&quot; or &quot;add input validation to the signup form&quot; and it just does it.<p>*Background:* I originally ran an instance of an open-source bot framework, but shut it down after a few days due to security concerns. I rebuilt from scratch on top of Claude Code&#x27;s CLI, which handles sandboxing and tool execution properly.<p>*No AI API keys required:* Kai doesn&#x27;t call the Anthropic API directly - it wraps a logged-in Claude Code session, so there are no API keys to manage and no per-token costs beyond your existing Claude Code subscription. The original design eliminated all API keys after security problems with another bot framework that managed them insecurely. Now that Kai runs on a trustworthy local foundation, optional service integrations are safe.<p>*Privacy angle:* Kai runs locally - on a Mac mini in my case. Conversations, credentials, and project files never leave the machine. There&#x27;s no server component, no cloud relay. Your Telegram messages go to your machine, and Claude Code handles the rest through Anthropic&#x27;s API directly.<p>*External services without MCP:* Kai has a declarative HTTP service layer for connecting to any REST API. You define services in a YAML config - URL, method, auth type - and Kai makes the HTTP calls directly. No plugins, no third-party server processes, no executable code. API keys stay in your `.env` and are never touched by intermediary code. Ships with a Perplexity config for web search, but the same pattern works for weather APIs, notification services (Pushover, ntfy), home automation, translation, or anything else with a REST endpoint. Entirely optional - Kai works fine without it.<p>*Some things it can do:*<p>- Connect to external REST APIs via declarative config (search, weather, notifications, etc.)\n- Transcribe voice messages locally (whisper.cpp) and respond with voice (Piper TTS)\n- Run scheduled jobs and reminders\n- Receive GitHub webhooks (push, PR, issue notifications)\n- Stream responses in real time (message updates every 2s)\n- Switch between workspaces and models via Telegram commands<p>It&#x27;s a single Python package, about 1700 lines across 11 modules. Runs as a launchd&#x2F;systemd service. Setup is: clone, pip install, set two env vars (Telegram token + your user ID), and `make run`.<p>Repo: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;dcellison&#x2F;kai\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;dcellison&#x2F;kai</a><p>Happy to answer any questions about the setup or architecture.","title":"Show HN: Kai \u2013 A Telegram bot that turns Claude Code into a personal dev asst","updated_at":"2026-02-16T16:43:59Z","url":"https://github.com/dcellison/kai"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"rookedsysc"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"I run multiple <em>Claude</em> <em>Code</em> agents in parallel across different branches. Checking each tmux session one by one to see which agent was working, waiting for input, or done was painful.<p>KanVibe is a self-hosted Kanban board for this. Three things it does:<p>- *Browser terminals*: Every task card has a live terminal (xterm.js). Click a task, see its output. No tmux attach needed.\n- *Hook-driven status tracking*: <em>Claude</em> <em>Code</em> Hooks auto-move cards across the board (PROGRESS \u2192 PENDING \u2192 REVIEW). Zero manual updates.\n- *Git worktree <em>automation</em>*: Create a task with a branch name \u2192 worktree + terminal session auto-created. Move to DONE \u2192 everything auto-cleaned.<p>Setup: `git clone` + `bash start.sh`. Requires Node.js 22+, tmux/zellij, and Docker.<p>Built with Next.js 16, React 19, PostgreSQL, xterm.js, and WebSocket. AGPL-3.0 licensed."},"title":{"matchLevel":"none","matchedWords":[],"value":"Show HN: KanVibe \u2013 Kanban board that auto-tracks AI agents via hooks"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://github.com/rookedsysc/kanvibe"}},"_tags":["story","author_rookedsysc","story_47034185","show_hn"],"author":"rookedsysc","created_at":"2026-02-16T12:27:38Z","created_at_i":1771244858,"num_comments":0,"objectID":"47034185","points":1,"story_id":47034185,"story_text":"I run multiple Claude Code agents in parallel across different branches. Checking each tmux session one by one to see which agent was working, waiting for input, or done was painful.<p>KanVibe is a self-hosted Kanban board for this. Three things it does:<p>- *Browser terminals*: Every task card has a live terminal (xterm.js). Click a task, see its output. No tmux attach needed.\n- *Hook-driven status tracking*: Claude Code Hooks auto-move cards across the board (PROGRESS \u2192 PENDING \u2192 REVIEW). Zero manual updates.\n- *Git worktree automation*: Create a task with a branch name \u2192 worktree + terminal session auto-created. Move to DONE \u2192 everything auto-cleaned.<p>Setup: `git clone` + `bash start.sh`. Requires Node.js 22+, tmux&#x2F;zellij, and Docker.<p>Built with Next.js 16, React 19, PostgreSQL, xterm.js, and WebSocket. AGPL-3.0 licensed.","title":"Show HN: KanVibe \u2013 Kanban board that auto-tracks AI agents via hooks","updated_at":"2026-02-16T12:31:00Z","url":"https://github.com/rookedsysc/kanvibe"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"tanmay001"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"AI agents often generate inconsistent Playwright tests because they do not understand your application\u2019s specific workflows, UI patterns, or constraints.<p>The Playwright Skill provides more than 70 structured markdown guides that teach patterns for locators, authentication, visual testing, CI configuration, and framework migration so agents can apply consistent solutions instead of guessing.<p>You install it with: npx skills add testdino-hq/playwright-skill.<p>The material is organized into five packs: core testing (46 guides), Playwright CLI usage for token\u2011efficient <em>automation</em> (10), Page Object Model patterns (2), CI/CD setup for major providers (9), and migrations from Cypress or Selenium (2).<p>Each guide follows the same structure\u2014when to use a pattern, when to avoid it, quick reference <em>code</em>, and complete implementations\u2014so learners can move from concept to reliable tests step by step.<p>The skill works with tools such as <em>Claude</em> <em>Code</em>, GitHub Copilot, Cursor, and any agent that implements the skills protocol, and it is MIT\u2011licensed so teams can adapt the content to their own standards and practices.<p>For a deeper walkthrough of the guides and structure, see the full article at <a href=\"https://testdino.com/blog/playwright-skill/\" rel=\"nofollow\">https://testdino.com/blog/playwright-skill/</a>."},"title":{"matchLevel":"none","matchedWords":[],"value":"Show HN: Train AI Agents to Write Better Playwright Tests"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://testdino.com/blog/playwright-skill/"}},"_tags":["story","author_tanmay001","story_47032774","show_hn"],"author":"tanmay001","created_at":"2026-02-16T09:18:10Z","created_at_i":1771233490,"num_comments":0,"objectID":"47032774","points":2,"story_id":47032774,"story_text":"AI agents often generate inconsistent Playwright tests because they do not understand your application\u2019s specific workflows, UI patterns, or constraints.<p>The Playwright Skill provides more than 70 structured markdown guides that teach patterns for locators, authentication, visual testing, CI configuration, and framework migration so agents can apply consistent solutions instead of guessing.<p>You install it with: npx skills add testdino-hq&#x2F;playwright-skill.<p>The material is organized into five packs: core testing (46 guides), Playwright CLI usage for token\u2011efficient automation (10), Page Object Model patterns (2), CI&#x2F;CD setup for major providers (9), and migrations from Cypress or Selenium (2).<p>Each guide follows the same structure\u2014when to use a pattern, when to avoid it, quick reference code, and complete implementations\u2014so learners can move from concept to reliable tests step by step.<p>The skill works with tools such as Claude Code, GitHub Copilot, Cursor, and any agent that implements the skills protocol, and it is MIT\u2011licensed so teams can adapt the content to their own standards and practices.<p>For a deeper walkthrough of the guides and structure, see the full article at <a href=\"https:&#x2F;&#x2F;testdino.com&#x2F;blog&#x2F;playwright-skill&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;testdino.com&#x2F;blog&#x2F;playwright-skill&#x2F;</a>.","title":"Show HN: Train AI Agents to Write Better Playwright Tests","updated_at":"2026-02-16T09:24:28Z","url":"https://testdino.com/blog/playwright-skill/"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"server-lab"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"I built DoScript, a domain-specific language for file <em>automation</em>. The goal: make scripts readable by anyone.\nDesign Goal\nInstead of:\nbashfind . -type f -mtime +30 -exec rm {} \\;\nWrite:\nfor_each file_in here\n    if_older_than {file_name} 30 days\n        delete file {file_path}\n    end_if\nend_for\nTrade power for clarity. Optimize for maintenance over terseness.\nKey Design Decisions\n1. Natural Language Keywords\nmake folder not mkdir, copy file not cp. Self-documenting.\n2. Implicit Metadata\nWhen iterating files, auto-inject: {file_name}, {file_path}, {file_size}, {file_modified}, {file_is_old_days}\nfor_each file_in &quot;Documents&quot;\n    say &quot;{file_name} is {file_size} bytes&quot;\nend_for\n3. Built-in Time Handling\nif_older_than {file_name} 30 days\nmake folder &quot;backup_{today}&quot;\nNo date arithmetic needed.\n4. Expression Evaluation\nFunction-based for simplicity:\nif greater_than {file_size} 1000000\nif and(equals({type}, &quot;pdf&quot;), greater_than({size}, 10000))\nIntentionally awkward for complex logic - signals you should use Python.\nImplementation<p>Python interpreter (~2000 LOC)\nRecursive descent parser\nContext-aware error reporting\nCustom exception types with file/line info<p>Visual Component\nBuilt a browser-based node editor (single HTML file, 1200 LOC). Drag boxes, wire them, generate DoScript <em>code</em>.\nWhy? Different learning styles, workflow visualization, non-programmer accessibility.\nWhat Worked<p>Natural syntax is immediately understandable\nMetadata injection removes boilerplate\nTime handling makes common cases trivial\nVisual IDE differentiates from text-only<p>What Didn't<p>Complex conditionals get awkward fast\nNo user-defined functions (only macros)\nLimited data structures\nPerformance not optimized<p>The Challenge\nBuilt for non-programmers. But they don't hang out on dev forums. Developers say &quot;just use Python&quot; - which misses the point.\nHow do you market dev tools to non-developers?\nTechnical Transparency\nI designed syntax and architecture. Most Python implementation was AI-assisted (<em>Claude</em>, Copilot). Focus on design, use tools for implementation.\nOpen Questions<p>When does a DSL become too limited?\nHow to market to non-developers?\nType system worth the complexity?\nShould DSLs provide escape hatches to host language?<p>GitHub: <a href=\"https://github.com/TheServer-lab/DoScript\" rel=\"nofollow\">https://github.com/TheServer-lab/DoScript</a>\nv0.6.5, includes interpreter, visual IDE, VS <em>Code</em> extension, examples.\nBuilt because bash was too cryptic for my friend to organize files. Turns out lots of people have this problem.\nWould love feedback from people who've built DSLs or struggled with similar trade-offs."},"title":{"fullyHighlighted":false,"matchLevel":"partial","matchedWords":["automation"],"value":"Show HN: DoScript \u2013 DSL for file <em>automation</em> with natural language syntax"},"url":{"matchLevel":"none","matchedWords":[],"value":"https://github.com/TheServer-lab/DoScript"}},"_tags":["story","author_server-lab","story_47032476","show_hn"],"author":"server-lab","created_at":"2026-02-16T08:37:57Z","created_at_i":1771231077,"num_comments":0,"objectID":"47032476","points":1,"story_id":47032476,"story_text":"I built DoScript, a domain-specific language for file automation. The goal: make scripts readable by anyone.\nDesign Goal\nInstead of:\nbashfind . -type f -mtime +30 -exec rm {} \\;\nWrite:\nfor_each file_in here\n    if_older_than {file_name} 30 days\n        delete file {file_path}\n    end_if\nend_for\nTrade power for clarity. Optimize for maintenance over terseness.\nKey Design Decisions\n1. Natural Language Keywords\nmake folder not mkdir, copy file not cp. Self-documenting.\n2. Implicit Metadata\nWhen iterating files, auto-inject: {file_name}, {file_path}, {file_size}, {file_modified}, {file_is_old_days}\nfor_each file_in &quot;Documents&quot;\n    say &quot;{file_name} is {file_size} bytes&quot;\nend_for\n3. Built-in Time Handling\nif_older_than {file_name} 30 days\nmake folder &quot;backup_{today}&quot;\nNo date arithmetic needed.\n4. Expression Evaluation\nFunction-based for simplicity:\nif greater_than {file_size} 1000000\nif and(equals({type}, &quot;pdf&quot;), greater_than({size}, 10000))\nIntentionally awkward for complex logic - signals you should use Python.\nImplementation<p>Python interpreter (~2000 LOC)\nRecursive descent parser\nContext-aware error reporting\nCustom exception types with file&#x2F;line info<p>Visual Component\nBuilt a browser-based node editor (single HTML file, 1200 LOC). Drag boxes, wire them, generate DoScript code.\nWhy? Different learning styles, workflow visualization, non-programmer accessibility.\nWhat Worked<p>Natural syntax is immediately understandable\nMetadata injection removes boilerplate\nTime handling makes common cases trivial\nVisual IDE differentiates from text-only<p>What Didn&#x27;t<p>Complex conditionals get awkward fast\nNo user-defined functions (only macros)\nLimited data structures\nPerformance not optimized<p>The Challenge\nBuilt for non-programmers. But they don&#x27;t hang out on dev forums. Developers say &quot;just use Python&quot; - which misses the point.\nHow do you market dev tools to non-developers?\nTechnical Transparency\nI designed syntax and architecture. Most Python implementation was AI-assisted (Claude, Copilot). Focus on design, use tools for implementation.\nOpen Questions<p>When does a DSL become too limited?\nHow to market to non-developers?\nType system worth the complexity?\nShould DSLs provide escape hatches to host language?<p>GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;TheServer-lab&#x2F;DoScript\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;TheServer-lab&#x2F;DoScript</a>\nv0.6.5, includes interpreter, visual IDE, VS Code extension, examples.\nBuilt because bash was too cryptic for my friend to organize files. Turns out lots of people have this problem.\nWould love feedback from people who&#x27;ve built DSLs or struggled with similar trade-offs.","title":"Show HN: DoScript \u2013 DSL for file automation with natural language syntax","updated_at":"2026-02-16T08:42:59Z","url":"https://github.com/TheServer-lab/DoScript"},{"_highlightResult":{"author":{"matchLevel":"none","matchedWords":[],"value":"tom2948329494"},"story_text":{"fullyHighlighted":false,"matchLevel":"full","matchedWords":["claude","code","automation"],"value":"I know everybody has their own note-taking system and there are better ways to do this, but:<p>Whenever I need to make quick notes during a meeting, or paste some url / <em>code</em> / whatever to hold it, or paste formatted text to un-format it, I used to open TextEdit.<p>It's the equivalent of taking a scrap piece of paper and jotting something down.<p>These kinds of notes I don't want in any cloud, serious note-taking app or any <em>code</em> editor.<p>But the burden of having 1 extra click on open (new document), and deciding what to do with old notes when closing (delete? save?) was too much.<p>So I built my own notepad which behaves like a super simple textedit, but all notes are <em>automati</em>cally saved to a predefined folder.<p>- Opens with a new note when launched, or re-opened.<p>- Notes can be auto-named by timestamp, numbered &quot;Note N&quot;, custom prefix or by first line of text.<p>- Hideable sidebar shows all notes.<p>- Shortcuts can create, delete, switch between notes.<p>Bonus points for pointing <em>claude</em> <em>code</em> to that folder to organize or work with all notes.<p>Again: This is a custom app I made for myself, so probably it's not useful to anyone, but anyhow:<p><a href=\"https://tomreinert.de/en/verygoodnotepad/\" rel=\"nofollow\">https://tomreinert.de/en/verygoodnotepad/</a><p><a href=\"https://apps.apple.com/us/app/very-good-notepad/id6758906859\">https://apps.apple.com/us/app/very-good-notepad/id6758906859</a><p>PS: This was built with the new <em>Claude</em> <em>Code</em> integration in xcode 26.3, worked quite well."},"title":{"matchLevel":"none","matchedWords":[],"value":"Show HN: Scratchpad app that auto-saves notes as .txt files"}},"_tags":["story","author_tom2948329494","story_47022138","show_hn"],"author":"tom2948329494","created_at":"2026-02-15T08:53:46Z","created_at_i":1771145626,"num_comments":0,"objectID":"47022138","points":1,"story_id":47022138,"story_text":"I know everybody has their own note-taking system and there are better ways to do this, but:<p>Whenever I need to make quick notes during a meeting, or paste some url &#x2F; code &#x2F; whatever to hold it, or paste formatted text to un-format it, I used to open TextEdit.<p>It&#x27;s the equivalent of taking a scrap piece of paper and jotting something down.<p>These kinds of notes I don&#x27;t want in any cloud, serious note-taking app or any code editor.<p>But the burden of having 1 extra click on open (new document), and deciding what to do with old notes when closing (delete? save?) was too much.<p>So I built my own notepad which behaves like a super simple textedit, but all notes are automatically saved to a predefined folder.<p>- Opens with a new note when launched, or re-opened.<p>- Notes can be auto-named by timestamp, numbered &quot;Note N&quot;, custom prefix or by first line of text.<p>- Hideable sidebar shows all notes.<p>- Shortcuts can create, delete, switch between notes.<p>Bonus points for pointing claude code to that folder to organize or work with all notes.<p>Again: This is a custom app I made for myself, so probably it&#x27;s not useful to anyone, but anyhow:<p><a href=\"https:&#x2F;&#x2F;tomreinert.de&#x2F;en&#x2F;verygoodnotepad&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;tomreinert.de&#x2F;en&#x2F;verygoodnotepad&#x2F;</a><p><a href=\"https:&#x2F;&#x2F;apps.apple.com&#x2F;us&#x2F;app&#x2F;very-good-notepad&#x2F;id6758906859\">https:&#x2F;&#x2F;apps.apple.com&#x2F;us&#x2F;app&#x2F;very-good-notepad&#x2F;id6758906859</a><p>PS: This was built with the new Claude Code integration in xcode 26.3, worked quite well.","title":"Show HN: Scratchpad app that auto-saves notes as .txt files","updated_at":"2026-02-15T08:58:25Z"}],"hitsPerPage":10,"nbHits":309,"nbPages":31,"page":0,"params":"query=Claude+Code+automation&tags=story&hitsPerPage=10&advancedSyntax=true&analyticsTags=backend","processingTimeMS":20,"processingTimingsMS":{"_request":{"roundTrip":22},"afterFetch":{"format":{"highlighting":1,"total":1}},"fetch":{"query":10,"scanning":8,"total":19},"total":20},"query":"Claude Code automation","serverTimeMS":21}
